
 <!DOCTYPE HTML>
<html lang="en">
<link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css">
<head>
  <meta charset="UTF-8">
  
    <title>【FreeRTOS】内存管理之heap-2源码分析 | Canrad&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Canrad">
    

    
    <meta name="description" content="heap_2.cheap_2的内存分配方式就与之前的heap_1差距比较大。我们主要关心pvPortMalloc和vPortFree函数。而pvPortCalloc只不过是对pvPortMalloc的进一步封装。下面我先列出heap_2.c中所有函数的作用。    函数名 作用    prvHeapInit 初始化堆   pvPortMalloc 申请内存（单纯申请，无其他操作）   vPortF">
<meta property="og:type" content="article">
<meta property="og:title" content="【FreeRTOS】内存管理之heap-2源码分析">
<meta property="og:url" content="https://luiox.github.io/article/10.html">
<meta property="og:site_name" content="Canrad&#39;s Blog">
<meta property="og:description" content="heap_2.cheap_2的内存分配方式就与之前的heap_1差距比较大。我们主要关心pvPortMalloc和vPortFree函数。而pvPortCalloc只不过是对pvPortMalloc的进一步封装。下面我先列出heap_2.c中所有函数的作用。    函数名 作用    prvHeapInit 初始化堆   pvPortMalloc 申请内存（单纯申请，无其他操作）   vPortF">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://luiox.github.io/assets/heap_2-1.jpg">
<meta property="og:image" content="https://luiox.github.io/assets/heap_2-2.jpg">
<meta property="og:image" content="https://luiox.github.io/assets/heap_2-3.jpg">
<meta property="og:image" content="https://luiox.github.io/assets/heap_2-4.jpg">
<meta property="article:published_time" content="2023-10-28T11:52:01.000Z">
<meta property="article:modified_time" content="2025-07-07T09:32:41.834Z">
<meta property="article:author" content="Canrad">
<meta property="article:tag" content="FreeRTOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luiox.github.io/assets/heap_2-1.jpg">

    
    <link rel="alternative" href="/atom.xml" title="Canrad&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.2.0"></head>

 <!-- 代码块复制功能 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js"></script>
<script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script type="text/javascript" src="/js/clipboard_use.js"></script>
  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Canrad&#39;s Blog">Canrad&#39;s Blog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:luiox.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/article/10.html" title="【FreeRTOS】内存管理之heap-2源码分析" itemprop="url">【FreeRTOS】内存管理之heap-2源码分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Canrad" target="_blank" itemprop="author">Canrad</a>
		
  <p class="article-time">
    <time datetime="2023-10-28T11:52:01.000Z" itemprop="datePublished"> Published 2023-10-28</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#heap-2-c"><span class="toc-number">1.</span> <span class="toc-text">heap_2.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockLink-t"><span class="toc-number">1.1.</span> <span class="toc-text">BlockLink_t</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A0%86"><span class="toc-number">1.2.</span> <span class="toc-text">初始化堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pvPortMalloc"><span class="toc-number">1.3.</span> <span class="toc-text">pvPortMalloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vPortFree"><span class="toc-number">1.4.</span> <span class="toc-text">vPortFree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pvPortCalloc"><span class="toc-number">1.5.</span> <span class="toc-text">pvPortCalloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%B3%A8%E9%87%8A%E7%9A%84pvPortMalloc%E4%BB%A3%E7%A0%81"><span class="toc-number">1.6.</span> <span class="toc-text">带注释的pvPortMalloc代码</span></a></li></ol></li></ol>
		
		</div>
		
		<h1 id="heap-2-c"><a href="#heap-2-c" class="headerlink" title="heap_2.c"></a>heap_2.c</h1><p><code>heap_2</code>的内存分配方式就与之前的<code>heap_1</code>差距比较大。我们主要关心<code>pvPortMalloc</code>和<code>vPortFree</code>函数。而<code>pvPortCalloc</code>只不过是对<code>pvPortMalloc</code>的进一步封装。下面我先列出<code>heap_2.c</code>中所有函数的作用。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>prvHeapInit</td>
<td>初始化堆</td>
</tr>
<tr>
<td>pvPortMalloc</td>
<td>申请内存（单纯申请，无其他操作）</td>
</tr>
<tr>
<td>vPortFree</td>
<td>归还内存</td>
</tr>
<tr>
<td>xPortGetFreeHeapSize</td>
<td>获取空闲内存大小</td>
</tr>
<tr>
<td>vPortInitialiseBlocks</td>
<td>初始化块</td>
</tr>
<tr>
<td>pvPortCalloc</td>
<td>申请内存（初始化为某个值）</td>
</tr>
</tbody></table>
<p>在对整个<code>heap_2</code>有了一定初步了解以后，接下来先看其中最重要的结构——链表。整个内存相关的操作都是围绕链表产生的，因此必须搞明白<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8">链表</a>是什么，然后再搞明白<code>FreeRTOS</code>中的这个链表。</p>
<h2 id="BlockLink-t"><a href="#BlockLink-t" class="headerlink" title="BlockLink_t"></a>BlockLink_t</h2><p><code>FreeRTOS</code>通过<code>BlockLink_t</code>结构体来制作了一个链表，从而让内存块连接起来，方便管理。下面是其定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A_BLOCK_LINK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A_BLOCK_LINK</span> * <span class="title">pxNextFreeBlock</span>;</span></span><br><span class="line">    <span class="type">size_t</span> xBlockSize;</span><br><span class="line">&#125; BlockLink_t;</span><br></pre></td></tr></table></figure>

<p>如果对链表有一定理解的话，那么就会想到，我们写的经典链表都是分为数据域和指针域的。也就是说链表的节点，一部分用于存储数据，一部分用于存放指针，指向下一个节点。这里不一样的地方在于需要标识一个内存块到底是不是空闲的。如果按照常规思路，势必需要定义一个变量用于存储当前这个内存块是否是空闲的，但是<code>FreeRTOS</code>把<code>xBlockSize</code>拆开来，从里面拿出一个最高位当做是是否是空闲内存块的标志位。这么做的目的就是减少管理内存时候产生的内存消耗。可以看下面这些在<code>heap_2.c</code>里的宏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 假设一个字节是8个位! */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapBITS_PER_BYTE           ((size_t)8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 假定使用size_t类型的最大值作为堆的最大值. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapSIZE_MAX                (~((size_t)0))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查a和b相乘是否会导致溢出. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapMULTIPLY_WILL_OVERFLOW(a, b)    (((a) &gt; 0) &amp;&amp; ((b) &gt; (heapSIZE_MAX / (a))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查a和b相加是否会导致溢出. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapADD_WILL_OVERFLOW(a, b)         ((a) &gt; ( heapSIZE_MAX - (b)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* BlockLink_t结构的xBlockSize成员的MSB用于跟踪块的分配状态。</span></span><br><span class="line"><span class="comment"> * 当BlockLink_t的xBlockSize成员的MSB被设置为1，则该块属于该应用程序。</span></span><br><span class="line"><span class="comment"> * 当该位为0时，该块是空闲堆空间的一部分。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapBLOCK_ALLOCATED_BITMASK    (((size_t)1) &lt;&lt; ((sizeof(size_t) * heapBITS_PER_BYTE) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapBLOCK_SIZE_IS_VALID(xBlockSize)    (((xBlockSize) &amp; heapBLOCK_ALLOCATED_BITMASK) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapBLOCK_IS_ALLOCATED(pxBlock)        (((pxBlock-&gt;xBlockSize) &amp; heapBLOCK_ALLOCATED_BITMASK) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapALLOCATE_BLOCK(pxBlock)            ((pxBlock-&gt;xBlockSize ) |= heapBLOCK_ALLOCATED_BITMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapFREE_BLOCK(pxBlock)                ((pxBlock-&gt;xBlockSize ) &amp;= ~heapBLOCK_ALLOCATED_BITMASK)</span></span><br></pre></td></tr></table></figure>

<p>首先<code>heapBITS_PER_BYTE</code>定义了一个字节的大小，因为之后做位运算的时候，<code>sizeof</code>计算得到的仅仅只是字节数，而不是位数，需要乘上一个字节有多少个位。然后看<code>heapBLOCK_ALLOCATED_BITMASK</code>，这是定义了分配内存块时候使用的一个掩码。<code>(sizeof(size_t) * heapBITS_PER_BYTE)</code>就是我所说的，利用<code>sizeof</code>和一个字节有多少个位，来计算<code>size_t</code>类型有多少个位，之后的减一目的是为了留一个位用于存储内存块的状态。<code>((size_t)1)</code>把1先扩展到<code>size_t</code>的大小，然后左移前面计算出来的位数，把1移到<code>size_t</code>的最高位。下面是一个示意图。<br><img src="/assets/heap_2-1.jpg" alt="heap_2-1"></p>
<p>理解掩码以后，再来看<code>heapBLOCK_IS_ALLOCATED</code>宏，就能理解<code>(((pxBlock-&gt;xBlockSize) &amp; heapBLOCK_ALLOCATED_BITMASK) != 0)</code>实际上就是通过按位与上掩码拿到<code>xBlockSize</code>的最高位。由此，也能推断出，最高位如果等于1代表这个内存块是被分配出去给应用程序了。在<code>FreeRTOS</code>原本的注释中写到<code>MSB</code>，实际上指的就是最高有效位（Most Significant Bit，MSB）。</p>
<p>接下来看剩余的宏，<code>heapBLOCK_SIZE_IS_VALID</code>用于判断一个内存块的大小是否是有效的。<code>(((xBlockSize) &amp; heapBLOCK_ALLOCATED_BITMASK) == 0)</code>刚好就是与上最高位，判断这个是否等于0，如果是0，则是代表这个内存块是空闲，也就是内存块还是属于堆。<code>heapALLOCATE_BLOCK(pxBlock) </code>宏的作用是拿到内存块的大小，因为我们之前占用了最高位，所以不能直接通过<code>xBlockSize</code>拿到内存块大小，而是只取除了最高位以外的31位。<code>heapFREE_BLOCK</code>则是设置一个内存块为空闲的内存块，也就是把最高位设置为0。</p>
<h2 id="初始化堆"><a href="#初始化堆" class="headerlink" title="初始化堆"></a>初始化堆</h2><p><code>heap_2.c</code>中初始化堆的工作是在<code>prvHeapInit</code>函数中进行的，这个函数通过使用<code>static</code>，让其只能在本文件内使用。</p>
<p>首先，<code>pucAlignedHeap</code>是和之前<code>heap_1.c</code>里面一样，都是通过位运算来计算堆内存对齐以后的起始位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PRIVILEGED_DATA <span class="type">static</span> BlockLink_t xStart, xEnd;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvHeapInit</span><span class="params">( <span class="type">void</span> )</span> <span class="comment">/* PRIVILEGED_FUNCTION */</span></span><br><span class="line">&#123;</span><br><span class="line">    BlockLink_t * pxFirstFreeBlock;</span><br><span class="line">    <span class="type">uint8_t</span> * pucAlignedHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保堆从正确对齐的边界开始。 */</span></span><br><span class="line">    pucAlignedHeap = ( <span class="type">uint8_t</span> * ) ( ( ( portPOINTER_SIZE_TYPE ) &amp; ucHeap[ portBYTE_ALIGNMENT - <span class="number">1</span> ] ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xStart用于保存指向空闲块列表中第一项的指针。void强制转换用于防止编译器警告。 */</span></span><br><span class="line">    xStart.pxNextFreeBlock = ( <span class="type">void</span> * ) pucAlignedHeap;</span><br><span class="line">    xStart.xBlockSize = ( <span class="type">size_t</span> ) <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xEnd用于标记空闲块列表的结束。 */</span></span><br><span class="line">    xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;</span><br><span class="line">    xEnd.pxNextFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 开始时，有一个空闲块，它的大小可以占用整个堆空间。     */</span></span><br><span class="line">    pxFirstFreeBlock = ( BlockLink_t * ) pucAlignedHeap;</span><br><span class="line">    pxFirstFreeBlock-&gt;xBlockSize = configADJUSTED_HEAP_SIZE;</span><br><span class="line">    pxFirstFreeBlock-&gt;pxNextFreeBlock = &amp;xEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>xStart</code>和<code>xEnd</code>是两个用于标识空闲列表的头和尾的结构。在初始化堆的时候，把整个堆都当成了空闲块，之后分配的时候就会更容易。</p>
<h2 id="pvPortMalloc"><a href="#pvPortMalloc" class="headerlink" title="pvPortMalloc"></a>pvPortMalloc</h2><p><code>heap_2</code>的<code>pvPortMalloc</code>跟之前<code>heap_1</code>完全不一样，为了能够回收内存，因此使用了链表来管理，这也就使得链表操作在内存管理里占了很大一部分。下面是这个函数内用的一些局部变量的定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlockLink_t * pxBlock;</span><br><span class="line">BlockLink_t * pxPreviousBlock;</span><br><span class="line">BlockLink_t * pxNewBlockLink;</span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> BaseType_t xHeapHasBeenInitialised = pdFALSE;</span><br><span class="line"><span class="type">void</span> * pvReturn = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">size_t</span> xAdditionalRequiredSize;</span><br></pre></td></tr></table></figure>

<p><code>pvPortMalloc</code>整个内存分配的过程还是一样，都要挂起所有任务，前面已经解释过为什么需要用<code>vTaskSuspendAll</code>和<code>xTaskResumeAll</code>了。</p>
<p>首先是利用一个静态变量在多次进入函数以后不会反复初始化的特性来做到一个判定是否是第一次进入，从而进行初始化堆的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如果这是第一次调用malloc，堆将需要</span></span><br><span class="line"><span class="comment"> *初始化以设置空闲块列表。*/</span></span><br><span class="line"><span class="keyword">if</span>( xHeapHasBeenInitialised == pdFALSE )</span><br><span class="line">&#123;</span><br><span class="line">    prvHeapInit();</span><br><span class="line">    xHeapHasBeenInitialised = pdTRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步就是内存对齐，这里牵扯到两个常量，补充说明一下。可以看下面的定义，<code>heapSTRUCT_SIZE</code>是一个常量，它表示<code>BlockLink_t</code>结构体的大小加上对齐要求后的大小。<code>sizeof(BlockLink_t)</code>用于计算<code>BlockLink_t</code>结构体的大小，而<code>(portBYTE_ALIGNMENT - 1)</code>用于计算对齐要求减去1的值。然后，通过将这两个值相加并使用按位与操作符<code>&amp;</code>与上一个掩码<code>~((size_t)portBYTE_ALIGNMENT_MASK)</code>，可以确保<code>heapSTRUCT_SIZE</code>满足对齐要求。</p>
<p>接下来，<code>heapMINIMUM_BLOCK_SIZE</code>是一个常量，它表示堆中最小块的大小。根据代码中的定义，最小块的大小是<code>heapSTRUCT_SIZE</code>的两倍。为什么这里规定最小块是两倍，因为如果一个内存块，管理内存所占用的内存大小比申请的内存大小还要大，那就造成了大量的浪费，因此也提醒我们，申请内存的时候不要申请很小，一次性多申请一些，之后再怎么使用，可以我们自己决定如何分割内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> heapSTRUCT_SIZE = ( ( <span class="keyword">sizeof</span>( BlockLink_t ) + ( portBYTE_ALIGNMENT - <span class="number">1</span> ) ) &amp; ~( ( <span class="type">size_t</span> ) portBYTE_ALIGNMENT_MASK ) );</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heapMINIMUM_BLOCK_SIZE    ( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )</span></span><br></pre></td></tr></table></figure>

<p>接着看，<code>xAdditionalRequiredSize</code>是额外的内存大小，也就是用于对齐我们申请内存的大小。之前尽管已经对<code>BlockLink_t</code>做了内存对齐，但是想要申请的内存大小可能不是内存对齐的，因此这里还是需要再对齐一次。<code>heapADD_WILL_OVERFLOW</code>这个宏的作用是判断两个相加的时候会不会产生溢出，因为我们把最高位拿过来用于标记内存块的状态了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( xWantedSize &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*需要的大小必须增加，以便它可以包含一个BlockLink_t</span></span><br><span class="line"><span class="comment">     *除了请求的字节数之外，还需要一个结构。</span></span><br><span class="line"><span class="comment">     *可能还需要一些额外的增量来对齐。*/</span></span><br><span class="line">    xAdditionalRequiredSize = heapSTRUCT_SIZE + portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        xWantedSize += xAdditionalRequiredSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        xWantedSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后便是检查和分配内存，这里一开始先判断了<code>xWantedSize</code>是否是可取的，因为如果想要申请的内存太大，就会导致后面分配内存时候出错。然后再是确保<code>xWantedSize</code>不是负数并且不能超过堆剩余的空闲内存大小，<code>xFreeBytesRemaining</code>是一个文件内的静态变量用于记录堆的空闲内存大小。<code>pxPreviousBlock</code>和<code>pxBlock</code>是两个指针，<code>while</code>用于遍历分配出去内存块的链表，直到找遍链表或者是找到一个足够大小的内存块。这个内存块的链表从头到尾，内存块的大小是从小到大，这样就可以保证分配出去的内存块一定是满足条件的最小内存块。</p>
<p>这里遍历链表的时候用了一个双指针的技巧。先以题目<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a>为例子来说明这个技巧。这个题目的要求是删除链表的倒数第N个节点。从题解，可以看出来，两个指针错位了N个位置的时候，由于<code>second</code>指针快N个位置，并且两个指针以一样的速度移动，因此当<code>second</code>指针到链表结束的时候，<code>first</code>指针刚好在离结束的N个位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    dummy-&gt;val = <span class="number">0</span>, dummy-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">first</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">second</span> =</span> dummy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first) &#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">ans</span> =</span> dummy-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(dummy);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>FreeRTOS</code>这个源码上，体现的就是，利用<code>pxBlock</code>比<code>pxPreviousBlock</code>快一个位置，这样就能获取到倒数第1个位置的值了，因为最后<code>pxPreviousBlock</code>必然会比<code>pxBlock</code>先到<code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( ( xWantedSize &gt; <span class="number">0</span> ) &amp;&amp; ( xWantedSize &lt;= xFreeBytesRemaining ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 块按字节顺序存储-从开始遍历列表</span></span><br><span class="line"><span class="comment">         * (最小)块，直到找到一个足够大小的块。 */</span></span><br><span class="line">        pxPreviousBlock = &amp;xStart;</span><br><span class="line">        pxBlock = xStart.pxNextFreeBlock;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( ( pxBlock-&gt;xBlockSize &lt; xWantedSize ) &amp;&amp; ( pxBlock-&gt;pxNextFreeBlock != <span class="literal">NULL</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            pxPreviousBlock = pxBlock;</span><br><span class="line">            pxBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果我们找到了结束标记，那么就没有找到足够大小的块。 */</span></span><br><span class="line">        <span class="keyword">if</span>( pxBlock != &amp;xEnd )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 返回内存空间跳过BlockLink_t结构开头。 */</span></span><br><span class="line">            pvReturn = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxPreviousBlock-&gt;pxNextFreeBlock ) + heapSTRUCT_SIZE );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 该块正在返回使用，因此必须从空闲块列表取出。 */</span></span><br><span class="line">            pxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果块大于要求，则可以将其分成两个。 */</span></span><br><span class="line">            <span class="keyword">if</span>( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 该块将被分成两个。创建一个新块</span></span><br><span class="line"><span class="comment">                 * 表示请求的字节数。void*转换的目的是                   </span></span><br><span class="line"><span class="comment">                 * 用于防止编译器发出字节对齐警告。*/</span></span><br><span class="line">                pxNewBlockLink = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxBlock ) + xWantedSize );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 计算从单个块分割的两个块的大小 */</span></span><br><span class="line">                pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;</span><br><span class="line">                pxBlock-&gt;xBlockSize = xWantedSize;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 插入新的块到空闲块列表. */</span></span><br><span class="line">                prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*块正在被返回-它被分配和拥有            </span></span><br><span class="line"><span class="comment">             *由应用程序执行，并且没有“next”块。*/</span></span><br><span class="line">            heapALLOCATE_BLOCK( pxBlock );</span><br><span class="line">            pxBlock-&gt;pxNextFreeBlock = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>if( pxBlock != &amp;xEnd )</code>实际上就是因为没有现成的内存块可以用于直接分配，因此要从空闲内存中分割出去一块合适的内存。</p>
<p>下面，从头开始，带入数据来说明具体的申请内存的细节。以申请20、40个字节的内存为例子来说明。首先，程序第一次调用<code>pvPortMalloc</code>的时候，先挂起所有的任务，然后<code>xWantedSize</code>是20，<code>xHeapHasBeenInitialised</code>是<code>pdFALSE</code>，因此要进入到<code>prvHeapInit</code>里面，之后把<code>xHeapHasBeenInitialised</code>设置为<code>pdTRUE</code>。进入到<code>prvHeapInit</code>里面，先假定<code>ucHeap</code>的地址是<code>0x20000058</code>，<code>pucAlignedHeap</code>通过<code>(uint8_t*) ( ( ( uint32_t) &amp;ucHeap[ 8 - 1 ] ) &amp; ( ~( ( uint32_t) 0x0007) ) )</code>被对齐为<code>0x20000060</code>。<code>xStart</code>的<code>pxNextFreeBlock</code>也是指向<code>pucAlignedHeap</code>，然后<code>xBlockSize</code>是0，<code>xEnd</code>是<code>( ( size_t ) ( 17 * 1024 ) ) - 8</code>也就是17400。在<code>prvHeapInit</code>的最后，初始化了一个自由内存块，其大小为<code>configADJUSTED_HEAP_SIZE</code>，也是就是调整以后堆的大小，开始于堆的起始位置，然后下一个空闲链表的指针指向<code>xEnd</code>。</p>
<p>接下来先计算<code>heapSTRUCT_SIZE</code>的值，<code>( ( 8 + ( 8- 1 ) ) &amp; ~( ( size_t ) 0x0007) )</code>也就是8。计算<code>8 + 8 - ( 20 &amp; 0x0007)</code>得到<code>xAdditionalRequiredSize</code>的值是12。因为不会溢出，所以<code>xWantedSize</code>加上对齐所需要的12个字节，就从20个字节变成了32个字节。</p>
<p>接着，又是判断<code>xWantedSize</code>的合法性，<code>pxPreviousBlock</code>指向了<code>xStart</code>的地址，<code>pxBlock</code>指向的是<code>xStart.pxNextFreeBlock</code>也就是堆通过内存对齐以后的起始地址。<code>xStart.pxNextFreeBlock.xBlockSize</code>也就是求之前初始化堆的时候，空闲内存块的大小，这个就是堆的大小，是绝对大于<code>xWantedSize</code>，所以<code>while</code>循环不会进去。</p>
<p>又因为没有找到结束标记，因此还是可以分配内存的。先用一个<code>pxNewBlockLink</code>指向新的空闲内存块的地址（<code>0x20000060+32</code>），然后<code>xBlockSize</code>是17400-32。然后原来以堆起始坐标开始的那个链表节点，把它的<code>xBlockSize</code>设置为32。之后再调用<code>prvInsertBlockIntoFreeList</code>把<code>pxNewBlockLink</code>插入到空闲链表里面。接下来分析这个插入链表的操作，这个<code>prvInsertBlockIntoFreeList</code>是一个宏，定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> prvInsertBlockIntoFreeList( pxBlockToInsert )                   \</span></span><br><span class="line"><span class="meta">    &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        BlockLink_t * pxIterator;                                       \</span></span><br><span class="line"><span class="meta">        size_t xBlockSize;                                              \</span></span><br><span class="line"><span class="meta">                                                                        \</span></span><br><span class="line"><span class="meta">        xBlockSize = pxBlockToInsert-&gt;xBlockSize;                       \</span></span><br><span class="line"><span class="meta">                                                                        \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* 遍历列表，直到找到一个比我们插入的块尺寸还要大的块 */</span>                \</span></span><br><span class="line"><span class="meta">        for(pxIterator = &amp;xStart;                                       \</span></span><br><span class="line"><span class="meta">            pxIterator-&gt;pxNextFreeBlock-&gt;xBlockSize &lt; xBlockSize;       \</span></span><br><span class="line"><span class="meta">            pxIterator = pxIterator-&gt;pxNextFreeBlock)                   \</span></span><br><span class="line"><span class="meta">        &#123;                                                               \</span></span><br><span class="line"><span class="meta">            <span class="comment">/* 这里什么也不做-只是迭代到正确的位置。 */</span>                       \</span></span><br><span class="line"><span class="meta">        &#125;                                                               \</span></span><br><span class="line"><span class="meta">                                                                        \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* 更新列表以包含插入到正确位置的块 */</span>                               \</span></span><br><span class="line"><span class="meta">        pxBlockToInsert-&gt;pxNextFreeBlock = pxIterator-&gt;pxNextFreeBlock; \</span></span><br><span class="line"><span class="meta">        pxIterator-&gt;pxNextFreeBlock = pxBlockToInsert;                  \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure>

<p>往<code>prvInsertBlockIntoFreeList</code>传入<code>pxNewBlockLink</code>，会被展开为如下内容。<code>xBlockSize</code>也是就<code>17400-32</code>，然后就会进入到<code>for</code>循环。一开始<code>pxIterator</code>指向的是<code>xStart</code>，之后因为，<code>xStart</code>的下一个，也就是前面分配出去的内存的大小，这个是小于<code>xBlockSize</code>的，这会导致<code>pxIterator</code>往后。这样循环，直到<code>pxIterator</code>指向了前面分配出去内存块的时候，它的下一个<code>xEnd</code>是大于它的，然后就停止循环。把<code>pxNewBlockLink-&gt;pxNextFreeBlock</code>指向<code>pxIterator-&gt;pxNextFreeBlock</code>，也就是<code>xEnd</code>，然后<code>pxIterator-&gt;pxNextFreeBlock</code>指向我们这个新的空闲内存块。此时就形成了<code>xStart -&gt; 0x20000060+32 -&gt; xEnd -&gt; NULL</code>这种链表。其中<code>0x20000060 </code>就是那个分配出去的内存块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    BlockLink_t * pxIterator;                               </span><br><span class="line">    <span class="type">size_t</span> xBlockSize;</span><br><span class="line">                                                            </span><br><span class="line">    xBlockSize = pxNewBlockLink-&gt;xBlockSize;                 </span><br><span class="line">                                                               </span><br><span class="line">    <span class="comment">/* 遍历列表，直到找到一个比我们插入的块尺寸还要大的块 */</span>  </span><br><span class="line">    <span class="keyword">for</span>(pxIterator = &amp;xStart;                              </span><br><span class="line">        pxIterator-&gt;pxNextFreeBlock-&gt;xBlockSize &lt; xBlockSize;</span><br><span class="line">        pxIterator = pxIterator-&gt;pxNextFreeBlock)         </span><br><span class="line">    &#123;                                                  </span><br><span class="line">        <span class="comment">/* 这里什么也不做-只是迭代到正确的位置。 */</span>  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新列表以包含插入到正确位置的块 */</span> </span><br><span class="line">    pxNewBlockLink-&gt;pxNextFreeBlock = pxIterator-&gt;pxNextFreeBlock;</span><br><span class="line">    pxIterator-&gt;pxNextFreeBlock = pxNewBlockLink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入空闲链表完成以后，就会通过<code>xFreeBytesRemaining</code>维护空闲内存的大小，然后利用<code>heapALLOCATE_BLOCK</code>宏设置<code>pxBlock</code>这个分配出去内存的大小，然后把<code>pxBlock</code>的下一个设成成为NULL，因为它已经被分配出去了。</p>
<p>接下来再用图回忆一遍，内存分配的过程。</p>
<p>首先是内存对齐。</p>
<p><img src="/assets/heap_2-2.jpg" alt="heap_2-2"></p>
<p>然后再是初始化堆，产生一个空闲内存块。</p>
<p><img src="/assets/heap_2-3.jpg" alt="heap_2-3"></p>
<p>接着是内存分配。</p>
<p><img src="/assets/heap_2-4.jpg" alt="heap_2-4"></p>
<h2 id="vPortFree"><a href="#vPortFree" class="headerlink" title="vPortFree"></a>vPortFree</h2><p>有了前面的了解，<code>vPortFree</code>就简单多了。下面直接看代码。首先是用<code>puc</code>来存储传入的<code>pv</code>指针所指向的地址，通过一个<code>if</code>来避免对<code>NULL</code>指针的释放。<code>FreeRTOS</code>中的注释“被释放的内存将立即具有BlockLink_t结构在这之前”，意思就是要让<code>puc</code>指针恢复到指向<code>BlockLink_t</code>结构的位置。通过前面的图，可以知道在用户申请内存块前面的<code>heapSTRUCT_SIZE</code>（这里就是8）个字节的位置刚好就是<code>BlockLink_t</code>结构的起始地址。再通过一个<code>pxLink</code>指针对<code>BlockLink_t</code>结构进行操作。<code>configASSERT</code>是一个断言，判断是否为真。必须为真才能正常运行，否则就说明这个内存块的<code>BlockLink_t</code>结构被修改，或者说是被破坏了导致的不合法。</p>
<p>再通过<code>heapBLOCK_IS_ALLOCATED</code>和<code>pxLink-&gt;pxNextFreeBlock</code>来确定这个内存块确实是一个被分配给用户的内存块。<code>heapFREE_BLOCK</code>这个释放内存块，就是把<code>BlockLink_t</code>结构中的最高位设置为0，表示这是一个空闲内存块。<code>configHEAP_CLEAR_MEMORY_ON_FREE</code>这个宏，是为了能够在清理内存的时候自动把空闲内存设置为0。</p>
<p>最后，又是挂起所有任务，然后将这个空闲内存块添加到空闲块链表中，然后维护<code>xFreeBytesRemaining</code>，把这个空闲内存的大小加回去。最后的最后，再恢复所有的任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> * pv )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> * puc = ( <span class="type">uint8_t</span> * ) pv;</span><br><span class="line">    BlockLink_t * pxLink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pv != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 被释放的内存将立即具有BlockLink_t结构在这之前。 */</span></span><br><span class="line">        puc -= heapSTRUCT_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 这种意想不到的强制转换是为了防止一些编译器发出字节对齐警告。*/</span></span><br><span class="line">        pxLink = ( <span class="type">void</span> * ) puc;</span><br><span class="line"></span><br><span class="line">        configASSERT( heapBLOCK_IS_ALLOCATED( pxLink ) != <span class="number">0</span> );</span><br><span class="line">        configASSERT( pxLink-&gt;pxNextFreeBlock == <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( heapBLOCK_IS_ALLOCATED( pxLink ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( pxLink-&gt;pxNextFreeBlock == <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 块被返回到堆中——它不再是分配。 */</span></span><br><span class="line">                heapFREE_BLOCK( pxLink );</span><br><span class="line">                <span class="meta">#<span class="keyword">if</span> ( configHEAP_CLEAR_MEMORY_ON_FREE == 1 )</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ( <span class="type">void</span> ) <span class="built_in">memset</span>( puc + heapSTRUCT_SIZE, <span class="number">0</span>, pxLink-&gt;xBlockSize - heapSTRUCT_SIZE );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                vTaskSuspendAll();</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 将此块添加到空闲块列表中。 */</span></span><br><span class="line">                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );</span><br><span class="line">                    xFreeBytesRemaining += pxLink-&gt;xBlockSize;</span><br><span class="line">                    traceFREE( pv, pxLink-&gt;xBlockSize );</span><br><span class="line">                &#125;</span><br><span class="line">                ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pvPortCalloc"><a href="#pvPortCalloc" class="headerlink" title="pvPortCalloc"></a>pvPortCalloc</h2><p><code>pvPortCalloc</code>本质上就是调用<code>pvPortMalloc</code>来申请一个<code>xNum * xSize</code>大小的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortCalloc</span><span class="params">( <span class="type">size_t</span> xNum,</span></span><br><span class="line"><span class="params">                     <span class="type">size_t</span> xSize )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * pv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        pv = pvPortMalloc( xNum * xSize );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pv != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ( <span class="type">void</span> ) <span class="built_in">memset</span>( pv, <span class="number">0</span>, xNum * xSize );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="带注释的pvPortMalloc代码"><a href="#带注释的pvPortMalloc代码" class="headerlink" title="带注释的pvPortMalloc代码"></a>带注释的pvPortMalloc代码</h2><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * pvPortMalloc( size_t xWantedSize )</span><br><span class="line">&#123;</span><br><span class="line">    BlockLink_t * pxBlock;</span><br><span class="line">    BlockLink_t * pxPreviousBlock;</span><br><span class="line">    BlockLink_t * pxNewBlockLink;</span><br><span class="line">    PRIVILEGED_DATA <span class="keyword">static</span> BaseType_t xHeapHasBeenInitialised = pdFALSE;</span><br><span class="line">    <span class="keyword">void</span> * pvReturn = NULL;</span><br><span class="line">    size_t xAdditionalRequiredSize;</span><br><span class="line"></span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*如果这是第一次调用malloc，堆将需要</span></span><br><span class="line"><span class="comment">         *初始化以设置空闲块列表。*/</span></span><br><span class="line">        <span class="keyword">if</span>( xHeapHasBeenInitialised == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            prvHeapInit();</span><br><span class="line">            xHeapHasBeenInitialised = pdTRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( xWantedSize &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*需要的大小必须增加，以便它可以包含一个BlockLink_t</span></span><br><span class="line"><span class="comment">             *除了请求的字节数之外，还需要一个结构。</span></span><br><span class="line"><span class="comment">             *可能还需要一些额外的增量来对齐。*/</span></span><br><span class="line">            xAdditionalRequiredSize = heapSTRUCT_SIZE + portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                xWantedSize += xAdditionalRequiredSize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                xWantedSize = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 检查我们尝试分配的块大小是否太大     </span></span><br><span class="line"><span class="comment">         * 顶部位已设置。BlockLink_t的块大小成员的顶部位   </span></span><br><span class="line"><span class="comment">         * 结构用于确定谁拥有块-应用程序或内核  ，</span></span><br><span class="line"><span class="comment">         * 所以它必须是空闲的。*/</span></span><br><span class="line">        <span class="keyword">if</span>( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( ( xWantedSize &gt; <span class="number">0</span> ) &amp;&amp; ( xWantedSize &lt;= xFreeBytesRemaining ) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 块按字节顺序存储-从开始遍历列表</span></span><br><span class="line"><span class="comment">                 * (最小)块，直到找到一个足够大小的块。 */</span></span><br><span class="line">                pxPreviousBlock = &amp;xStart;</span><br><span class="line">                pxBlock = xStart.pxNextFreeBlock;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>( ( pxBlock-&gt;xBlockSize &lt; xWantedSize ) &amp;&amp; ( pxBlock-&gt;pxNextFreeBlock != NULL ) )</span><br><span class="line">                &#123;</span><br><span class="line">                    pxPreviousBlock = pxBlock;</span><br><span class="line">                    pxBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 如果我们找到了结束标记，那么就没有找到足够大小的块。 */</span></span><br><span class="line">                <span class="keyword">if</span>( pxBlock != &amp;xEnd )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 返回内存空间跳过BlockLink_t结构开头。 */</span></span><br><span class="line">                    pvReturn = ( <span class="keyword">void</span> * ) ( ( ( uint8_t * ) pxPreviousBlock-&gt;pxNextFreeBlock ) + heapSTRUCT_SIZE );</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 该块正在返回使用，因此必须从空闲块列表取出。 */</span></span><br><span class="line">                    pxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 如果块大于要求，则可以将其分成两个。 */</span></span><br><span class="line">                    <span class="keyword">if</span>( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* 该块将被分成两个。创建一个新块</span></span><br><span class="line"><span class="comment">                         * 表示请求的字节数。void*转换的目的是                   </span></span><br><span class="line"><span class="comment">                         * 用于防止编译器发出字节对齐警告。*/</span></span><br><span class="line">                        pxNewBlockLink = ( <span class="keyword">void</span> * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 计算从单个块分割的两个块的大小 */</span></span><br><span class="line">                        pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;</span><br><span class="line">                        pxBlock-&gt;xBlockSize = xWantedSize;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 插入新的块到空闲块列表. */</span></span><br><span class="line">                        prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*块正在被返回-它被分配和拥有            </span></span><br><span class="line"><span class="comment">                     *由应用程序执行，并且没有“next”块。*/</span></span><br><span class="line">                    heapALLOCATE_BLOCK( pxBlock );</span><br><span class="line">                    pxBlock-&gt;pxNextFreeBlock = NULL;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traceMALLOC( pvReturn, xWantedSize );</span><br><span class="line">    &#125;</span><br><span class="line">    ( <span class="keyword">void</span> ) xTaskResumeAll();</span><br><span class="line"></span><br><span class="line">    #<span class="keyword">if</span> ( configUSE_MALLOC_FAILED_HOOK == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( pvReturn == NULL )</span><br><span class="line">        &#123;</span><br><span class="line">            vApplicationMallocFailedHook();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #endif</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pvReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/FreeRTOS/">FreeRTOS</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://luiox.github.io/article/10.html" data-title="【FreeRTOS】内存管理之heap-2源码分析 | Canrad&#39;s Blog" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/article/11.html" title="二零二三年十一月一日">
  <strong>上一篇：</strong><br/>
  <span>
  二零二三年十一月一日</span>
</a>
</div>


<div class="next">
<a href="/article/9.html"  title="Java基础知识整理">
 <strong>下一篇：</strong><br/> 
 <span>Java基础知识整理
</span>
</a>
</div>

</nav>

	



    <script>
        document.addEventListener('DOMContentLoaded', function() {
        // 为每个代码块添加复制按钮
        document.querySelectorAll('.article-content .highlight').forEach(function(codeBlock) {
            var button = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = '复制';
            button.title = '复制代码';
            button.addEventListener('click', function() {
                // 使用Clipboard.js复制代码块的内容到剪贴板
                var clipboard = new ClipboardJS(button, {
                    text: function(trigger) {
                        // 找到按钮所在的代码块
                        var codeBlock = trigger.closest('.highlight');
                        // 获取所有的<pre>元素
                        var preElements = codeBlock.querySelectorAll('pre');
                        // 返回第二个<pre>元素的innerText
                        return preElements[1].innerText;
                    }
                });
                
                clipboard.on('success', function(e) {
                    //alert('代码复制成功');
                    e.clearSelection();
                    // 显示“复制成功”
                    button.textContent = '复制成功';
                    // 5秒后恢复为“复制”
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 5000);
                });
                clipboard.on('error', function(e) {
                    //alert('代码复制失败');
                    e.clearSelection();
                    // 显示“复制成功”
                    button.textContent = '复制失败';
                    // 5秒后恢复为“复制”
                    setTimeout(function() {
                        button.textContent = '复制';
                    }, 5000);
                    });
            });
            codeBlock.insertBefore(button, codeBlock.firstChild);
            });
        });
    </script>
</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#heap-2-c"><span class="toc-number">1.</span> <span class="toc-text">heap_2.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockLink-t"><span class="toc-number">1.1.</span> <span class="toc-text">BlockLink_t</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A0%86"><span class="toc-number">1.2.</span> <span class="toc-text">初始化堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pvPortMalloc"><span class="toc-number">1.3.</span> <span class="toc-text">pvPortMalloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vPortFree"><span class="toc-number">1.4.</span> <span class="toc-text">vPortFree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pvPortCalloc"><span class="toc-number">1.5.</span> <span class="toc-text">pvPortCalloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%B3%A8%E9%87%8A%E7%9A%84pvPortMalloc%E4%BB%A3%E7%A0%81"><span class="toc-number">1.6.</span> <span class="toc-text">带注释的pvPortMalloc代码</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Daily/" title="Daily">Daily<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/FreeRTOS/" title="FreeRTOS">FreeRTOS<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/OCaml/" title="OCaml">OCaml<sup>1</sup></a></li>
			
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> This is Canrad&#39;s home page. <br/>
			</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		
				<div class="cc-license">
          <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
            <img src="/img/cc-by-nc-sa.svg" alt="Creative Commons" />
          </a>
        </div>
    

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2025 
		
		<a href="/about" target="_blank" title="Canrad">Canrad</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
